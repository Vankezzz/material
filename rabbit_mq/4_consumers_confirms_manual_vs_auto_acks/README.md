# Описание
Данный пример демонстрирует архитектуру fanout с двумя work_queues
> consumer_1 не подтверждает обработанные сообщения. 
> Реализован как неправиьный потребитель

> consumer_2 подтверждает обработанные сообщения. 
> Реализован как нормальный потребитель с ручным подтверждением

Дополнительно: 

При выполнении команды channel.basic_consume() мы можем указать auto_ack=True (по умолчанию False).
Брокер просто передает сообщение потребителю и без подтверждения считает доставку успешной - **"fire-and-forget"**.
Хорошо для пропускной способности, но не гарантирует надежную доставку
```
consumer_tag = channel.basic_consume(
    queue=queue_1,
    on_message_callback=callback,
    auto_ack=False  # "fire-and-forget"
)
```

## Запуск примера
1. Запустить consumer_1 в одном терминале в двух экземплярах и убедиться в том, 
что они привязаны к одному queue_1 с разными идентификаторами (consumer_tag)
```shell
python.exe consumer_1.py
```
2. Запустить consumer_2 в одном терминале в двух экземплярах и убедиться в том, 
что они привязаны к одному queue_2 с разными идентификаторами (consumer_tag)
```shell
python.exe consumer_dlq.py
```
3. Убедиться в UI, что схема работает ("Queues and Streams").