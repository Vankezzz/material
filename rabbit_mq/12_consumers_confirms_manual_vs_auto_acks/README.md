# Описание
Данный пример демонстрирует архитектуру fanout с двумя work_queues
> consumer_1 не подтверждает обработанные сообщения. 
> Реализован как неправиьный потребитель

> consumer_2 подтверждает обработанные сообщения. 
> Реализован как нормальный потребитель с ручным подтверждением

Дополнительно: 

При выполнении команды channel.basic_consume() мы можем указать auto_ack=True (по умолчанию False).
Брокер просто передает сообщение потребителю и без подтверждения считает доставку успешной - **"fire-and-forget"**.
Хорошо для пропускной способности, но не гарантирует надежную доставку
```
consumer_tag = channel.basic_consume(
    queue=queue_1,
    on_message_callback=callback,
    auto_ack=False  # "fire-and-forget"
)
```

## Запуск примера
1. Запустить consumer_1 в одном терминале в двух экземплярах и убедиться в том, 
что они привязаны к одному queue_1 с разными идентификаторами (consumer_tag)
```shell
python.exe consumer.py
```
2. Запустить consumer_2 в одном терминале в двух экземплярах и убедиться в том, 
что они привязаны к одному queue_2 с разными идентификаторами (consumer_tag)
```shell
python.exe consumer_dlq.py
```
3. Убедиться в UI, что схема работает ("Queues and Streams").


Настройка Acknowledgement Timeout в конфигурации (по умолчанию 30 минут) - https://www.rabbitmq.com/consumers.html#acknowledgement-timeout
Настройка в consumer подтверждения https://www.rabbitmq.com/confirms.html
Пример с ручным ACK тут https://www.rabbitmq.com/tutorials/tutorial-two-python.html

Если потребитель умирает (его канал закрыт, соединение закрыто или соединение TCP потеряно) 
без отправки подтверждения, RabbitMQ поймет, что сообщение 
не было полностью обработано, и повторно поставит его в очередь.
Если в, то же время в сети есть другие потребители, 
он быстро повторно доставит его другому потребителю. 
Таким образом, вы можете быть уверены, что ни одно сообщение не будет потеряно,
даже если работники иногда умирают

Если пропустить basic_ack(), то сообщение обработается в приложение, но не пришлет подтверждение, 
тогда сообщение будет повторно отправлено очередь со статусом `unacknowledged' и снова обработано приложением